# -*- coding: utf-8 -*-
# Forward calculation with a pre-trained network
# Seung-Chan Kim
# https://iamtrask.github.io/2015/11/15/anyone-can-code-lstm/
import copy, numpy as np
import matplotlib.pyplot as plt

np.random.seed(0)
# compute sigmoid nonlinearity
def sigmoid(x):
    output = 1/(1+np.exp(-x))
    return output

synapse_0 = [[ -3.59519530e-01,   2.33958993e+00,  -3.20338283e-01,
         -1.23380148e+00,   8.23329522e-02,  -1.45748081e-01,
         -6.45250995e+00,   4.49331950e+00,   3.26692732e+00,
         -1.20738586e+00,   1.15429892e+00,  -2.40883011e-03,
         -1.33888050e+00,   8.52716118e-01,  -5.14494757e+00,
         -1.06330714e+00],
       [ -2.68069543e+00,   1.89873078e+00,   1.87995848e+00,
          1.36240935e+00,   1.49624674e+00,   1.13808369e+00,
          5.07559597e+00,   3.84828275e+00,  -1.60133079e+00,
         -6.85907484e-01,  -2.99388346e+00,   3.72908685e+00,
         -2.03880654e+00,  -1.85161240e+00,  -5.18525010e+00,
          1.15066749e+00]]

synapse_1 = [[ 2.03071179],
       [-0.66162995],
       [-2.46164979],
       [-2.14926531],
       [-1.316041  ],
       [-1.26025501],
       [ 7.9664284 ],
       [ 6.39502015],
       [-1.38569981],
       [-0.28722474],
       [ 1.84409219],
       [-3.92645053],
       [ 1.06560186],
       [ 0.96352614],
       [-8.58559082],
       [-2.02362742]]
synapse_h = [[ 0.03181292, -1.57610668,  0.02068267,  0.15980357,  0.51340376,
        -0.54424461, -2.37928976,  0.16707457, -0.10072398, -0.07600941,
         0.09385251, -1.18412748,  0.50169375, -0.43218294,  1.58562712,
        -0.54266278],
       [-0.65419518,  0.22925434,  0.76290475, -0.83081858,  0.67274591,
        -0.66477158,  2.73452205, -2.35568549,  1.6093527 , -0.18013518,
        -0.46082073, -0.47483798, -0.79219389, -1.4475196 , -1.74391352,
        -0.67660372],
       [-0.29566957, -0.14515312, -0.96830975,  0.24622941, -0.00588823,
        -0.33812007,  0.93265849, -1.61233371,  0.68600202,  0.3934923 ,
        -1.00488647,  0.20010635, -0.80244805, -0.10380378, -0.60413093,
        -0.78597967],
       [ 0.15943183, -1.34861031,  0.58052277, -0.79993508,  0.17865188,
        -0.41207984, -0.6390113 ,  1.13361444, -0.49446918,  0.21561124,
        -0.03540312,  0.06256037, -0.13271672,  0.96838917,  0.74859709,
         0.73047402],
       [ 0.34869417, -0.2431448 ,  0.61619874, -0.27138817,  0.70766359,
         0.29838068,  1.66712502, -0.93158872,  1.02359046, -0.46577053,
         0.06179862,  0.52136402, -0.4659724 , -0.43674099, -1.41580205,
        -0.45366324],
       [ 0.12436744, -0.13425276,  0.19222372, -0.050556  , -0.55385554,
        -0.13988762,  0.50394111, -0.8090668 ,  0.5253116 , -0.12963408,
        -0.28035719, -0.08840669,  0.52029958, -0.84576588, -0.71729001,
         0.77746124],
       [ 1.18032983, -0.95224643, -1.19507943,  1.05081765,  0.00652372,
         0.96173471, -2.41926577,  1.63630089, -0.90617352,  0.58054031,
        -0.27354501, -0.66075364,  1.35042705,  0.68751897,  1.68421467,
        -0.77307115],
       [ 1.11105834, -1.04905073,  0.04878561,  0.8126651 ,  0.20047739,
         0.40857149, -1.25233084,  0.87260283,  0.10607076,  0.08100951,
        -0.0704001 , -1.09310938,  0.68790574, -0.59887111,  0.55503872,
        -0.39693485],
       [-0.31040234,  0.92768181,  0.3978287 , -0.9246784 , -0.7558818 ,
         0.66933396,  1.86431354, -2.20293814,  1.35168391, -0.35416802,
        -0.68689088,  0.10906915,  0.32033828, -1.288814  , -1.49078566,
        -0.49590446],
       [-0.28218851, -0.26628482,  0.34265901,  0.04403331, -1.10214692,
        -0.48419089, -2.38505233,  0.87989146, -0.5262599 ,  0.7186787 ,
        -0.1440471 , -1.18837266,  0.02346226, -0.48749235,  1.53628314,
        -0.12545696],
       [ 0.4340515 , -0.62742089,  0.84567214, -0.31368354, -0.1729571 ,
        -0.21270624, -2.2271734 ,  1.24506826, -0.76829302,  0.07778248,
         0.46123087, -0.2290079 ,  1.55825931,  0.98848587,  0.63211562,
         0.84318512],
       [-0.48095922,  1.25608632,  0.2525628 , -0.72019784,  0.82385304,
         0.31849202,  0.89306824, -1.70791041,  0.57434782, -1.11819422,
        -1.16787109, -0.11624765, -0.56187563, -0.43328798, -1.06240294,
         0.09348005],
       [ 1.10375198, -1.84870891, -0.23875625, -0.52964414,  0.09403066,
        -0.03487203, -1.50815526,  0.7442655 , -1.09837206,  0.3297744 ,
         0.03361467,  0.13758756,  1.65449918,  0.83370811,  1.51217242,
        -0.79356488],
       [ 0.59035046, -1.14848827,  0.69580869, -0.20384397, -1.07977277,
        -0.74877129, -2.33023849,  1.88741274, -0.12612334,  1.13006919,
        -0.06686066, -0.64959205,  0.46163558,  0.45794248,  2.02077812,
         0.947547  ],
       [-0.69301034,  1.09375177, -0.44975003,  0.66410715,  1.09781567,
         0.80014258,  0.02553356,  1.21997398,  0.00698922,  0.14474051,
        -0.01058037, -0.71710903, -0.52475367, -1.20956399,  0.29715381,
        -0.30589397],
       [ 0.11550181, -0.27654194, -0.3428275 , -0.51735203,  0.44155736,
        -0.57633273, -1.2621032 , -0.05282625, -0.88338172,  0.90145372,
         0.91711727,  0.58807147,  1.41716245,  0.74379707,  0.94776698,
        -0.74644035]]

print ('synapse_0 ', np.array(synapse_0).shape)
print ('synapse_1 ', np.array(synapse_1).shape)
print ('synapse_h ', np.array(synapse_h).shape)

print ('========')

input_dim = 2
hidden_dim = 16
output_dim = 1


# training dataset generation
int2binary = {}
binary_dim = 8

largest_number = pow(2,binary_dim)

binary = np.unpackbits(
    np.array([range(largest_number)],dtype=np.uint8).T,axis=1)

for i in range(largest_number):
    int2binary[i] = binary[i]


a_int = np.random.randint(largest_number / 2)  # int version
a = int2binary[a_int]  # binary encoding

b_int = np.random.randint(largest_number / 2)  # int version
b = int2binary[b_int]  # binary encoding

# true answer
c_int = a_int + b_int
c = int2binary[c_int]

print "a:" + str(a) + " = " + str(a_int)
print "b:" + str(b) + " = " + str(b_int)

layer_1_values = []
layer_1_values.append(np.zeros(hidden_dim))

# where we'll store our best guess (binary encoded)
d = np.zeros_like(c)

for position in range(binary_dim):
    # generate input and output
    # LSB 부터 연산시작
    X = np.array([[a[binary_dim - position - 1], b[binary_dim - position - 1]]])
    y = np.array([[c[binary_dim - position - 1]]])

    # layer_1 = sigmoid(np.dot(X, synapse_0) # no carry bit
    layer_1 = sigmoid(np.dot(X, synapse_0) + np.dot(layer_1_values[-1], synapse_h))
    # output layer (new binary representation)
    layer_2 = sigmoid(np.dot(layer_1, synapse_1))

    # decode estimate so we can print it out
    d[binary_dim - position - 1] = np.round(layer_2[0][0])
    layer_1_values.append(copy.deepcopy(layer_1))


ddec = 0
for index, x in enumerate(reversed(d)):
    ddec += x * pow(2, index)

print "Pred:" + str(d) + " = " + str(ddec)
print "True:" + str(c) + " = " + str(c_int)

